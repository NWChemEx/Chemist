<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chemist: chemist::braket::BraKet&lt; BraType, OperatorType, KetType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chemist
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacechemist.html">chemist</a></li><li class="navelem"><b>braket</b></li><li class="navelem"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classchemist_1_1braket_1_1BraKet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">chemist::braket::BraKet&lt; BraType, OperatorType, KetType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Specifies the calculation (or a piece of it) that the user wants.  
 <a href="classchemist_1_1braket_1_1BraKet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="braket__class_8hpp_source.html">braket_class.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for chemist::braket::BraKet&lt; BraType, OperatorType, KetType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classchemist_1_1braket_1_1BraKet__inherit__graph.png" border="0" usemap="#achemist_1_1braket_1_1BraKet_3_01BraType_00_01OperatorType_00_01KetType_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="achemist_1_1braket_1_1BraKet_3_01BraType_00_01OperatorType_00_01KetType_01_4_inherit__map" id="achemist_1_1braket_1_1BraKet_3_01BraType_00_01OperatorType_00_01KetType_01_4_inherit__map">
<area shape="rect" title="Specifies the calculation (or a piece of it) that the user wants." alt="" coords="23,109,211,165"/>
<area shape="rect" title=" " alt="" coords="5,5,229,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for chemist::braket::BraKet&lt; BraType, OperatorType, KetType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classchemist_1_1braket_1_1BraKet__coll__graph.png" border="0" usemap="#achemist_1_1braket_1_1BraKet_3_01BraType_00_01OperatorType_00_01KetType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="achemist_1_1braket_1_1BraKet_3_01BraType_00_01OperatorType_00_01KetType_01_4_coll__map" id="achemist_1_1braket_1_1BraKet_3_01BraType_00_01OperatorType_00_01KetType_01_4_coll__map">
<area shape="rect" title="Specifies the calculation (or a piece of it) that the user wants." alt="" coords="23,109,211,165"/>
<area shape="rect" title=" " alt="" coords="5,5,229,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97ab8218229d9b242c6f4578b1d1e0af"><td class="memItemLeft" align="right" valign="top"><a id="a97ab8218229d9b242c6f4578b1d1e0af"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a97ab8218229d9b242c6f4578b1d1e0af">base_type</a> = detail_::bra_ket_base_type&lt; BraType, OperatorType, KetType &gt;</td></tr>
<tr class="memdesc:a97ab8218229d9b242c6f4578b1d1e0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type *this inherits from. <br /></td></tr>
<tr class="separator:a97ab8218229d9b242c6f4578b1d1e0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56fed9b245f4de3a6691019e1078853"><td class="memItemLeft" align="right" valign="top"><a id="ad56fed9b245f4de3a6691019e1078853"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ad56fed9b245f4de3a6691019e1078853">base_pointer</a> = typename base_type::base_pointer</td></tr>
<tr class="memdesc:ad56fed9b245f4de3a6691019e1078853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the base class. <br /></td></tr>
<tr class="separator:ad56fed9b245f4de3a6691019e1078853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c96e7f1601ec1b29175213bbb54349"><td class="memItemLeft" align="right" valign="top"><a id="aa5c96e7f1601ec1b29175213bbb54349"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa5c96e7f1601ec1b29175213bbb54349">const_base_reference</a> = typename base_type::const_base_reference</td></tr>
<tr class="memdesc:aa5c96e7f1601ec1b29175213bbb54349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to an object fo type base_type. <br /></td></tr>
<tr class="separator:aa5c96e7f1601ec1b29175213bbb54349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9853925bfb753288922ba28c1a5378e"><td class="memItemLeft" align="right" valign="top"><a id="af9853925bfb753288922ba28c1a5378e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#af9853925bfb753288922ba28c1a5378e">bra_type</a> = BraType</td></tr>
<tr class="memdesc:af9853925bfb753288922ba28c1a5378e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the bra object. <br /></td></tr>
<tr class="separator:af9853925bfb753288922ba28c1a5378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df8828ed29bc4581566273a24abcbf9"><td class="memItemLeft" align="right" valign="top"><a id="a1df8828ed29bc4581566273a24abcbf9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a1df8828ed29bc4581566273a24abcbf9">bra_reference</a> = <a class="el" href="classchemist_1_1braket_1_1BraKet.html#af9853925bfb753288922ba28c1a5378e">bra_type</a> &amp;</td></tr>
<tr class="memdesc:a1df8828ed29bc4581566273a24abcbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type behaving like a mutable reference to a bra_type object. <br /></td></tr>
<tr class="separator:a1df8828ed29bc4581566273a24abcbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8344ace2af59308d6cee32dd923e9bca"><td class="memItemLeft" align="right" valign="top"><a id="a8344ace2af59308d6cee32dd923e9bca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a8344ace2af59308d6cee32dd923e9bca">const_bra_reference</a> = const <a class="el" href="classchemist_1_1braket_1_1BraKet.html#af9853925bfb753288922ba28c1a5378e">bra_type</a> &amp;</td></tr>
<tr class="memdesc:a8344ace2af59308d6cee32dd923e9bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type behaving like a read-only reference to a bra_type object. <br /></td></tr>
<tr class="separator:a8344ace2af59308d6cee32dd923e9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a8e702bbc2fb609fab80b84808597e"><td class="memItemLeft" align="right" valign="top"><a id="a02a8e702bbc2fb609fab80b84808597e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a02a8e702bbc2fb609fab80b84808597e">operator_type</a> = OperatorType</td></tr>
<tr class="memdesc:a02a8e702bbc2fb609fab80b84808597e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the operator. <br /></td></tr>
<tr class="separator:a02a8e702bbc2fb609fab80b84808597e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae577e8c987f0566a7d5096421e3320ad"><td class="memItemLeft" align="right" valign="top"><a id="ae577e8c987f0566a7d5096421e3320ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ae577e8c987f0566a7d5096421e3320ad">operator_reference</a> = <a class="el" href="classchemist_1_1braket_1_1BraKet.html#a02a8e702bbc2fb609fab80b84808597e">operator_type</a> &amp;</td></tr>
<tr class="memdesc:ae577e8c987f0566a7d5096421e3320ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type behaving like a mutable reference to an operator_type object. <br /></td></tr>
<tr class="separator:ae577e8c987f0566a7d5096421e3320ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bf6d0ff4cc4206a0e62bf14800ed2"><td class="memItemLeft" align="right" valign="top"><a id="a864bf6d0ff4cc4206a0e62bf14800ed2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a864bf6d0ff4cc4206a0e62bf14800ed2">const_operator_reference</a> = const <a class="el" href="classchemist_1_1braket_1_1BraKet.html#a02a8e702bbc2fb609fab80b84808597e">operator_type</a> &amp;</td></tr>
<tr class="memdesc:a864bf6d0ff4cc4206a0e62bf14800ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type behaving like a read-only reference to an operator_type object. <br /></td></tr>
<tr class="separator:a864bf6d0ff4cc4206a0e62bf14800ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50b8ff30b527b5ae74f5ada55a8ee92"><td class="memItemLeft" align="right" valign="top"><a id="aa50b8ff30b527b5ae74f5ada55a8ee92"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa50b8ff30b527b5ae74f5ada55a8ee92">ket_type</a> = KetType</td></tr>
<tr class="memdesc:aa50b8ff30b527b5ae74f5ada55a8ee92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the ket object. <br /></td></tr>
<tr class="separator:aa50b8ff30b527b5ae74f5ada55a8ee92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cb3d7fee97d4e3483266931101f6e2"><td class="memItemLeft" align="right" valign="top"><a id="a30cb3d7fee97d4e3483266931101f6e2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a30cb3d7fee97d4e3483266931101f6e2">ket_reference</a> = <a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa50b8ff30b527b5ae74f5ada55a8ee92">ket_type</a> &amp;</td></tr>
<tr class="memdesc:a30cb3d7fee97d4e3483266931101f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type behaving like a mutable reference to a ket_type object. <br /></td></tr>
<tr class="separator:a30cb3d7fee97d4e3483266931101f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d340cd75ee0a7010ebbb0180eefa76"><td class="memItemLeft" align="right" valign="top"><a id="a19d340cd75ee0a7010ebbb0180eefa76"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a19d340cd75ee0a7010ebbb0180eefa76">const_ket_reference</a> = const <a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa50b8ff30b527b5ae74f5ada55a8ee92">ket_type</a> &amp;</td></tr>
<tr class="memdesc:a19d340cd75ee0a7010ebbb0180eefa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type behaving like a read-only reference to a ket_type object. <br /></td></tr>
<tr class="separator:a19d340cd75ee0a7010ebbb0180eefa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae6ca192ab140cfb811f42ae9cca6f964"><td class="memTemplParams" colspan="2">template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 &gt; </td></tr>
<tr class="memitem:ae6ca192ab140cfb811f42ae9cca6f964"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ae6ca192ab140cfb811f42ae9cca6f964">BraKet</a> (BraType2 &amp;&amp;<a class="el" href="classchemist_1_1braket_1_1BraKet.html#a68576261254d387e131cae2f7894f42c">bra</a>, OperatorType2 &amp;&amp;<a class="el" href="classchemist_1_1braket_1_1BraKet.html#aaba64fd86eb615753b97d50bded3313a">op</a>, KetType2 &amp;&amp;<a class="el" href="classchemist_1_1braket_1_1BraKet.html#a99fa182d1f92a74e5c3e568660f2542c">ket</a>)</td></tr>
<tr class="memdesc:ae6ca192ab140cfb811f42ae9cca6f964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> with the given bra, operator, and ket.  <a href="classchemist_1_1braket_1_1BraKet.html#ae6ca192ab140cfb811f42ae9cca6f964">More...</a><br /></td></tr>
<tr class="separator:ae6ca192ab140cfb811f42ae9cca6f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d820d50b4b557a3fe94df28d9a3cdf1"><td class="memTemplParams" colspan="2"><a id="a0d820d50b4b557a3fe94df28d9a3cdf1"></a>
template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 , typename  = enable_if_conversion_t&lt;BraType2, OperatorType2, KetType2&gt;&gt; </td></tr>
<tr class="memitem:a0d820d50b4b557a3fe94df28d9a3cdf1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BraKet</b> (const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType2, OperatorType2, KetType2 &gt; &amp;other)</td></tr>
<tr class="separator:a0d820d50b4b557a3fe94df28d9a3cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb5fbb7f281644edae60c56d297980a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a0cb5fbb7f281644edae60c56d297980a">BraKet</a> (const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> &amp;other)</td></tr>
<tr class="memdesc:a0cb5fbb7f281644edae60c56d297980a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this with a deep copy of <code>other</code>.  <a href="classchemist_1_1braket_1_1BraKet.html#a0cb5fbb7f281644edae60c56d297980a">More...</a><br /></td></tr>
<tr class="separator:a0cb5fbb7f281644edae60c56d297980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdafb4f8acec7a8605e33abfdaa6ed1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#afbdafb4f8acec7a8605e33abfdaa6ed1">BraKet</a> (<a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:afbdafb4f8acec7a8605e33abfdaa6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes *this by taking the state from <code>other</code>.  <a href="classchemist_1_1braket_1_1BraKet.html#afbdafb4f8acec7a8605e33abfdaa6ed1">More...</a><br /></td></tr>
<tr class="separator:afbdafb4f8acec7a8605e33abfdaa6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac64e06e425a5300880e85b2c05dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a2aac64e06e425a5300880e85b2c05dd2">operator=</a> (const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2aac64e06e425a5300880e85b2c05dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the state in *this with a deep copy of the state in <code>rhs</code>.  <a href="classchemist_1_1braket_1_1BraKet.html#a2aac64e06e425a5300880e85b2c05dd2">More...</a><br /></td></tr>
<tr class="separator:a2aac64e06e425a5300880e85b2c05dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a3db5f326f1530910ea34bac013f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a731a3db5f326f1530910ea34bac013f7">operator=</a> (<a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> &amp;&amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:a731a3db5f326f1530910ea34bac013f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the state in *this with the state from <code>rhs</code>.  <a href="classchemist_1_1braket_1_1BraKet.html#a731a3db5f326f1530910ea34bac013f7">More...</a><br /></td></tr>
<tr class="separator:a731a3db5f326f1530910ea34bac013f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68576261254d387e131cae2f7894f42c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a1df8828ed29bc4581566273a24abcbf9">bra_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a68576261254d387e131cae2f7894f42c">bra</a> ()</td></tr>
<tr class="memdesc:a68576261254d387e131cae2f7894f42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the bra's state.  <a href="classchemist_1_1braket_1_1BraKet.html#a68576261254d387e131cae2f7894f42c">More...</a><br /></td></tr>
<tr class="separator:a68576261254d387e131cae2f7894f42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa339d903dcad7b4c01b6f186695de16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a8344ace2af59308d6cee32dd923e9bca">const_bra_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa339d903dcad7b4c01b6f186695de16d">bra</a> () const</td></tr>
<tr class="memdesc:aa339d903dcad7b4c01b6f186695de16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the bra's state.  <a href="classchemist_1_1braket_1_1BraKet.html#aa339d903dcad7b4c01b6f186695de16d">More...</a><br /></td></tr>
<tr class="separator:aa339d903dcad7b4c01b6f186695de16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba64fd86eb615753b97d50bded3313a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ae577e8c987f0566a7d5096421e3320ad">operator_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#aaba64fd86eb615753b97d50bded3313a">op</a> ()</td></tr>
<tr class="memdesc:aaba64fd86eb615753b97d50bded3313a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the operator.  <a href="classchemist_1_1braket_1_1BraKet.html#aaba64fd86eb615753b97d50bded3313a">More...</a><br /></td></tr>
<tr class="separator:aaba64fd86eb615753b97d50bded3313a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c4c49f054ba5e0701e1b4430d1512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a864bf6d0ff4cc4206a0e62bf14800ed2">const_operator_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a2a4c4c49f054ba5e0701e1b4430d1512">op</a> () const</td></tr>
<tr class="memdesc:a2a4c4c49f054ba5e0701e1b4430d1512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the operator.  <a href="classchemist_1_1braket_1_1BraKet.html#a2a4c4c49f054ba5e0701e1b4430d1512">More...</a><br /></td></tr>
<tr class="separator:a2a4c4c49f054ba5e0701e1b4430d1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fa182d1f92a74e5c3e568660f2542c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a30cb3d7fee97d4e3483266931101f6e2">ket_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a99fa182d1f92a74e5c3e568660f2542c">ket</a> ()</td></tr>
<tr class="memdesc:a99fa182d1f92a74e5c3e568660f2542c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the ket's state.  <a href="classchemist_1_1braket_1_1BraKet.html#a99fa182d1f92a74e5c3e568660f2542c">More...</a><br /></td></tr>
<tr class="separator:a99fa182d1f92a74e5c3e568660f2542c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab209de9060b2a70642ac55f0d5060744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a19d340cd75ee0a7010ebbb0180eefa76">const_ket_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ab209de9060b2a70642ac55f0d5060744">ket</a> () const</td></tr>
<tr class="memdesc:ab209de9060b2a70642ac55f0d5060744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the ket's state.  <a href="classchemist_1_1braket_1_1BraKet.html#ab209de9060b2a70642ac55f0d5060744">More...</a><br /></td></tr>
<tr class="separator:ab209de9060b2a70642ac55f0d5060744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24a297ceec13b5afc4fe796f2fb5c8e"><td class="memTemplParams" colspan="2">template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 &gt; </td></tr>
<tr class="memitem:ab24a297ceec13b5afc4fe796f2fb5c8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ab24a297ceec13b5afc4fe796f2fb5c8e">operator==</a> (const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType2, OperatorType2, KetType2 &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ab24a297ceec13b5afc4fe796f2fb5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is *this value equal to <code>rhs</code>?  <a href="classchemist_1_1braket_1_1BraKet.html#ab24a297ceec13b5afc4fe796f2fb5c8e">More...</a><br /></td></tr>
<tr class="separator:ab24a297ceec13b5afc4fe796f2fb5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae970c6027dbc17fbe464bca2373d29da"><td class="memTemplParams" colspan="2">template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 &gt; </td></tr>
<tr class="memitem:ae970c6027dbc17fbe464bca2373d29da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ae970c6027dbc17fbe464bca2373d29da">operator!=</a> (const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType2, OperatorType2, KetType2 &gt; &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ae970c6027dbc17fbe464bca2373d29da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is *this different from <code>rhs</code>?  <a href="classchemist_1_1braket_1_1BraKet.html#ae970c6027dbc17fbe464bca2373d29da">More...</a><br /></td></tr>
<tr class="separator:ae970c6027dbc17fbe464bca2373d29da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aae3c1eff1ab74c0fcb1874e099b34d8a"><td class="memItemLeft" align="right" valign="top"><a id="aae3c1eff1ab74c0fcb1874e099b34d8a"></a>
<a class="el" href="classchemist_1_1braket_1_1BraKet.html#ad56fed9b245f4de3a6691019e1078853">base_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#aae3c1eff1ab74c0fcb1874e099b34d8a">clone_</a> () const override</td></tr>
<tr class="memdesc:aae3c1eff1ab74c0fcb1874e099b34d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements clone by calling copy ctor. <br /></td></tr>
<tr class="separator:aae3c1eff1ab74c0fcb1874e099b34d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daf6b07e31be26ae83e54338fce70ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a0daf6b07e31be26ae83e54338fce70ec">are_equal_</a> (<a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa5c96e7f1601ec1b29175213bbb54349">const_base_reference</a> rhs) const noexcept override</td></tr>
<tr class="separator:a0daf6b07e31be26ae83e54338fce70ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BraType, typename OperatorType, typename KetType&gt;<br />
class chemist::braket::BraKet&lt; BraType, OperatorType, KetType &gt;</h3>

<p>Specifies the calculation (or a piece of it) that the user wants. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BraType</td><td>Type of the object </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae6ca192ab140cfb811f42ae9cca6f964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ca192ab140cfb811f42ae9cca6f964">&#9670;&nbsp;</a></span>BraKet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<div class="memtemplate">
template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::<a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> </td>
          <td>(</td>
          <td class="paramtype">BraType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>bra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OperatorType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KetType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>ket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> with the given bra, operator, and ket. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BraType2</td><td>The type of <code>bra</code>. Must be implicitly convertible to BraType. </td></tr>
    <tr><td class="paramname">OperatorType2</td><td>The type of <code>op</code>. Must be implicitly convertible to OperatorType. </td></tr>
    <tr><td class="paramname">KetType2</td><td>The type of <code>ket</code>. Must be implicitly convertible to KetType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is templated so we can automatically handle copying and moving of the inputs as appropriate.</dd></dl>
<p>This ctor is used to create a stateful <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bra</td><td>The wavefunction or vector space associated with the bra. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operator acting on the ket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ket</td><td>The wavefunction or vector space associated with the ket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if forwarding any of the arguments throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cb5fbb7f281644edae60c56d297980a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb5fbb7f281644edae60c56d297980a">&#9670;&nbsp;</a></span>BraKet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::<a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType, OperatorType, KetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes *this with a deep copy of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating *this. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbdafb4f8acec7a8605e33abfdaa6ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdafb4f8acec7a8605e33abfdaa6ed1">&#9670;&nbsp;</a></span>BraKet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::<a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType, OperatorType, KetType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes *this by taking the state from <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> to take the state from. After this operator <code>other</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0daf6b07e31be26ae83e54338fce70ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0daf6b07e31be26ae83e54338fce70ec">&#9670;&nbsp;</a></span>are_equal_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::are_equal_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#aa5c96e7f1601ec1b29175213bbb54349">const_base_reference</a>&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements are_equal by downcasting <code>rhs</code> and comparing via operator== </p>

</div>
</div>
<a id="a68576261254d387e131cae2f7894f42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68576261254d387e131cae2f7894f42c">&#9670;&nbsp;</a></span>bra() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a1df8828ed29bc4581566273a24abcbf9">bra_reference</a> <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::bra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the bra's state. </p>
<p>TL;DR this function probably does exactly what you think it does, but the description is trying to be mathematically rigorous to avoid questions.</p>
<p>Formally the bra of a bra-ket is a linear function mapping the ket to a scalar. The linear function responsible for this mapping is usually (always?) the inner product with the adjoint of the specified vector, e.g., <img class="formulaInl" alt="$\bra{u}$" src="form_38.png"/> is short hand for "multiply from the left by u
dagger".</p>
<p>If this bra-ket is a tensor element, then this method returns the adjoint of the vector the linear function should multiply by (e.g., in the example above you get back "u" NOT "u dagger"), i.e., to evaluate the bra-ket represented by *this you need to take the adjoint of the return before left multiplying it with the ket).</p>
<p>If this bra-ket is a tensor representation the tensor element description still applies, just now for every vector in the vector space. In other words, the returned vector space is in its "ket form", e.g., if the 0-th vector in the return is "u", then to form the 0-th row of the matrix *this represent you need to left multiply each ket vector by "u dagger".</p>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the bra.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa339d903dcad7b4c01b6f186695de16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa339d903dcad7b4c01b6f186695de16d">&#9670;&nbsp;</a></span>bra() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a8344ace2af59308d6cee32dd923e9bca">const_bra_reference</a> <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::bra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the bra's state. </p>
<p>This method works identically to the non-const version except that the result is read-only. See the description for the non-const version for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the bra.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99fa182d1f92a74e5c3e568660f2542c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fa182d1f92a74e5c3e568660f2542c">&#9670;&nbsp;</a></span>ket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a30cb3d7fee97d4e3483266931101f6e2">ket_reference</a> <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::ket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the ket's state. </p>
<p>Formally, the ket in a bra-ket is always a vector. Here the ket can be a single vector or a set of vectors depending on whether *this represents a single tensor element or the entire tensor. This method returns the vector if *this is a tensor element, and the vector space if *this is a tensor representation.</p>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the ket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab209de9060b2a70642ac55f0d5060744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab209de9060b2a70642ac55f0d5060744">&#9670;&nbsp;</a></span>ket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a19d340cd75ee0a7010ebbb0180eefa76">const_ket_reference</a> <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::ket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the ket's state. </p>
<p>This method works identically to the non-const version except that the result is read-only. See the description for the non-const version for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the ket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba64fd86eb615753b97d50bded3313a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba64fd86eb615753b97d50bded3313a">&#9670;&nbsp;</a></span>op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#ae577e8c987f0566a7d5096421e3320ad">operator_reference</a> <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the operator. </p>
<p>Each bra-ket object has an operator associated with it, even if it is an overlap bra-ket (in which case the operator is the identity operator). This method is used to retrieve the operator.</p>
<dl class="section note"><dt>Note</dt><dd>"operator" is a keyword in C++ so we op-ted (ha) to break our guidelines and abbreviate it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable reference to the operator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a4c4c49f054ba5e0701e1b4430d1512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4c4c49f054ba5e0701e1b4430d1512">&#9670;&nbsp;</a></span>op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html#a864bf6d0ff4cc4206a0e62bf14800ed2">const_operator_reference</a> <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the operator. </p>
<p>This method works identically to the non-const version except that the result is read-only. See the description for the non-const version for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the operator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae970c6027dbc17fbe464bca2373d29da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae970c6027dbc17fbe464bca2373d29da">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<div class="memtemplate">
template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType2, OperatorType2, KetType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is *this different from <code>rhs</code>? </p>
<p>This method defines "different" as "not value equal" and thus simply negates the result of operator==. See the description of operator== for the definition of value equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BraType2</td><td>The type of object <code>rhs</code> has for a bra. </td></tr>
    <tr><td class="paramname">OperatorType2</td><td>The type of object <code>rhs</code> has for an operator. </td></tr>
    <tr><td class="paramname">KetType2</td><td>The type of object <code>rhs</code> has for a ket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The bra-ket to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if *this is value equal to <code>rhs</code> and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a731a3db5f326f1530910ea34bac013f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731a3db5f326f1530910ea34bac013f7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&amp; <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType, OperatorType, KetType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the state in *this with the state from <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> to take the state from. After this call <code>rhs</code> will be in a valid but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after overwriting its state with the state from <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aac64e06e425a5300880e85b2c05dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aac64e06e425a5300880e85b2c05dd2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&amp; <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType, OperatorType, KetType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the state in *this with a deep copy of the state in <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> whose state will be deep copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this after overwriting its state with a deep copy of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the copy. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24a297ceec13b5afc4fe796f2fb5c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24a297ceec13b5afc4fe796f2fb5c8e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BraType , typename OperatorType , typename KetType &gt; </div>
<div class="memtemplate">
template&lt;typename BraType2 , typename OperatorType2 , typename KetType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchemist_1_1braket_1_1BraKet.html">chemist::braket::BraKet</a>&lt; BraType, OperatorType, KetType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1braket_1_1BraKet.html">BraKet</a>&lt; BraType2, OperatorType2, KetType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is *this value equal to <code>rhs</code>? </p>
<p>Two <a class="el" href="classchemist_1_1braket_1_1BraKet.html" title="Specifies the calculation (or a piece of it) that the user wants.">BraKet</a> objects are value equal if:</p><ul>
<li>They have the same values for each template type parameter</li>
<li>the bra states compare equal,</li>
<li>the operator states compare equal, and</li>
<li>the ket states compare equal.</li>
</ul>
<p>N.b. this operator is templated on the types so that users can compare bra-kets with different types (interacting with mixed types happens in generic programming).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BraType2</td><td>The type of the bra object stored in <code>rhs</code>. </td></tr>
    <tr><td class="paramname">OperatorType2</td><td>The type of the operator object stored in <code>rhs</code>. </td></tr>
    <tr><td class="paramname">KetType2</td><td>The type of the ket object stored in <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the bra-ket object to compare to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this is value equal to <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/chemist/quantum_mechanics/braket/<a class="el" href="braket__class_8hpp_source.html">braket_class.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
