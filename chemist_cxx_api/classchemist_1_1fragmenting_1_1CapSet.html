<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chemist: chemist::fragmenting::CapSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">chemist<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacechemist.html">chemist</a></li><li class="navelem"><b>fragmenting</b></li><li class="navelem"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html">CapSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classchemist_1_1fragmenting_1_1CapSet-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">chemist::fragmenting::CapSet Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The set of caps associated with a fragment.  
 <a href="classchemist_1_1fragmenting_1_1CapSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cap__set_8hpp_source.html">cap_set.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for chemist::fragmenting::CapSet:</div>
<div class="dyncontent">
<div class="center"><img src="classchemist_1_1fragmenting_1_1CapSet__inherit__graph.png" border="0" usemap="#achemist_1_1fragmenting_1_1CapSet_inherit__map" alt="Inheritance graph"/></div>
<map name="achemist_1_1fragmenting_1_1CapSet_inherit__map" id="achemist_1_1fragmenting_1_1CapSet_inherit__map">
<area shape="rect" title="The set of caps associated with a fragment." alt="" coords="27,93,190,133"/>
<area shape="rect" title=" " alt="" coords="5,5,212,45"/>
<area shape="poly" title=" " alt="" coords="111,59,111,93,106,93,106,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for chemist::fragmenting::CapSet:</div>
<div class="dyncontent">
<div class="center"><img src="classchemist_1_1fragmenting_1_1CapSet__coll__graph.png" border="0" usemap="#achemist_1_1fragmenting_1_1CapSet_coll__map" alt="Collaboration graph"/></div>
<map name="achemist_1_1fragmenting_1_1CapSet_coll__map" id="achemist_1_1fragmenting_1_1CapSet_coll__map">
<area shape="rect" title="The set of caps associated with a fragment." alt="" coords="27,93,190,133"/>
<area shape="rect" title=" " alt="" coords="5,5,212,45"/>
<area shape="poly" title=" " alt="" coords="111,59,111,93,106,93,106,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3db5aec49302fe3ea084439b36d848d9" id="r_a3db5aec49302fe3ea084439b36d848d9"><td class="memItemLeft" align="right" valign="top"><a id="a3db5aec49302fe3ea084439b36d848d9" name="a3db5aec49302fe3ea084439b36d848d9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = <a class="el" href="classchemist_1_1fragmenting_1_1Cap.html">Cap</a></td></tr>
<tr class="memdesc:a3db5aec49302fe3ea084439b36d848d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of each cap. <br /></td></tr>
<tr class="separator:a3db5aec49302fe3ea084439b36d848d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293ffbee579bbd85a5cc4e1950621916" id="r_a293ffbee579bbd85a5cc4e1950621916"><td class="memItemLeft" align="right" valign="top"><a id="a293ffbee579bbd85a5cc4e1950621916" name="a293ffbee579bbd85a5cc4e1950621916"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3db5aec49302fe3ea084439b36d848d9">value_type</a> &amp;</td></tr>
<tr class="memdesc:a293ffbee579bbd85a5cc4e1950621916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a mutable reference to a cap. <br /></td></tr>
<tr class="separator:a293ffbee579bbd85a5cc4e1950621916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad379a5401c0643b2a01b7695238bb1d7" id="r_ad379a5401c0643b2a01b7695238bb1d7"><td class="memItemLeft" align="right" valign="top"><a id="ad379a5401c0643b2a01b7695238bb1d7" name="ad379a5401c0643b2a01b7695238bb1d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3db5aec49302fe3ea084439b36d848d9">value_type</a> &amp;</td></tr>
<tr class="memdesc:ad379a5401c0643b2a01b7695238bb1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a cap. <br /></td></tr>
<tr class="separator:ad379a5401c0643b2a01b7695238bb1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94d5533fe6c9a88aad1d7a813821638" id="r_aa94d5533fe6c9a88aad1d7a813821638"><td class="memItemLeft" align="right" valign="top"><a id="aa94d5533fe6c9a88aad1d7a813821638" name="aa94d5533fe6c9a88aad1d7a813821638"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nucleus_type</b> = <a class="el" href="classchemist_1_1Nucleus.html">Nucleus</a></td></tr>
<tr class="memdesc:aa94d5533fe6c9a88aad1d7a813821638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a nucleus. <br /></td></tr>
<tr class="separator:aa94d5533fe6c9a88aad1d7a813821638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd0c72619f005c03abb2ca2ca959c1" id="r_ac9bd0c72619f005c03abb2ca2ca959c1"><td class="memItemLeft" align="right" valign="top"><a id="ac9bd0c72619f005c03abb2ca2ca959c1" name="ac9bd0c72619f005c03abb2ca2ca959c1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>nuclei_reference</b> = <a class="el" href="classchemist_1_1NucleiView.html">NucleiView</a>&lt; <a class="el" href="classchemist_1_1Nuclei.html">Nuclei</a> &gt;</td></tr>
<tr class="memdesc:ac9bd0c72619f005c03abb2ca2ca959c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a mutable reference to a set of cap nuclei. <br /></td></tr>
<tr class="separator:ac9bd0c72619f005c03abb2ca2ca959c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab055da917e74cd5c23f66d5fcc27bf39" id="r_ab055da917e74cd5c23f66d5fcc27bf39"><td class="memItemLeft" align="right" valign="top"><a id="ab055da917e74cd5c23f66d5fcc27bf39" name="ab055da917e74cd5c23f66d5fcc27bf39"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_nuclei_reference</b> = <a class="el" href="classchemist_1_1NucleiView.html">NucleiView</a>&lt; const <a class="el" href="classchemist_1_1Nuclei.html">Nuclei</a> &gt;</td></tr>
<tr class="memdesc:ab055da917e74cd5c23f66d5fcc27bf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a read-only reference to a set of cap nuclei. <br /></td></tr>
<tr class="separator:ab055da917e74cd5c23f66d5fcc27bf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acd0e48a950ddd73d7a6452b9716960" id="r_a8acd0e48a950ddd73d7a6452b9716960"><td class="memItemLeft" align="right" valign="top"><a id="a8acd0e48a950ddd73d7a6452b9716960" name="a8acd0e48a950ddd73d7a6452b9716960"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_nucleus_reference</b> = <a class="el" href="classchemist_1_1fragmenting_1_1Cap.html#ac929e90767c1b9de9cd82a20be694f8a">value_type::const_reference</a></td></tr>
<tr class="memdesc:a8acd0e48a950ddd73d7a6452b9716960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a const reference to a nucleus. <br /></td></tr>
<tr class="separator:a8acd0e48a950ddd73d7a6452b9716960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdf8e8c8968ac3345e41b61ca112624" id="r_a1fdf8e8c8968ac3345e41b61ca112624"><td class="memItemLeft" align="right" valign="top"><a id="a1fdf8e8c8968ac3345e41b61ca112624" name="a1fdf8e8c8968ac3345e41b61ca112624"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename base_type::size_type</td></tr>
<tr class="memdesc:a1fdf8e8c8968ac3345e41b61ca112624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets by this class. Unsigned integral. <br /></td></tr>
<tr class="separator:a1fdf8e8c8968ac3345e41b61ca112624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d658d762436cea8a70e090ed07c2d6e" id="r_a2d658d762436cea8a70e090ed07c2d6e"><td class="memItemLeft" align="right" valign="top"><a id="a2d658d762436cea8a70e090ed07c2d6e" name="a2d658d762436cea8a70e090ed07c2d6e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>index_set_type</b> = std::set&lt; <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a1fdf8e8c8968ac3345e41b61ca112624">size_type</a> &gt;</td></tr>
<tr class="memdesc:a2d658d762436cea8a70e090ed07c2d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to specify a set of indices. <br /></td></tr>
<tr class="separator:a2d658d762436cea8a70e090ed07c2d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a14f9f28d03190f645fa5a0475422d1a4" id="r_a14f9f28d03190f645fa5a0475422d1a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a14f9f28d03190f645fa5a0475422d1a4">CapSet</a> ()=default</td></tr>
<tr class="memdesc:a14f9f28d03190f645fa5a0475422d1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates ane empty <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a>.  <br /></td></tr>
<tr class="separator:a14f9f28d03190f645fa5a0475422d1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa222cd7235f4b569e14bf257f7d83e9b" id="r_aa222cd7235f4b569e14bf257f7d83e9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#aa222cd7235f4b569e14bf257f7d83e9b">CapSet</a> (std::initializer_list&lt; <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3db5aec49302fe3ea084439b36d848d9">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:aa222cd7235f4b569e14bf257f7d83e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a> initialized to the values in <code>il</code>.  <br /></td></tr>
<tr class="separator:aa222cd7235f4b569e14bf257f7d83e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e0900400dfd9715e76e76d7e085e4e" id="r_a91e0900400dfd9715e76e76d7e085e4e"><td class="memTemplParams" colspan="2">template&lt;typename BeginItr , typename EndItr &gt; </td></tr>
<tr class="memitem:a91e0900400dfd9715e76e76d7e085e4e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a91e0900400dfd9715e76e76d7e085e4e">CapSet</a> (BeginItr &amp;&amp;begin, EndItr &amp;&amp;end)</td></tr>
<tr class="memdesc:a91e0900400dfd9715e76e76d7e085e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a> from a range of <a class="el" href="classchemist_1_1fragmenting_1_1Cap.html" title="Caps a severed bond.">Cap</a> objects.  <br /></td></tr>
<tr class="separator:a91e0900400dfd9715e76e76d7e085e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e580adfc3e150a95e29a2399a5ae0e" id="r_a94e580adfc3e150a95e29a2399a5ae0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a94e580adfc3e150a95e29a2399a5ae0e">push_back</a> (<a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3db5aec49302fe3ea084439b36d848d9">value_type</a> cap)</td></tr>
<tr class="memdesc:a94e580adfc3e150a95e29a2399a5ae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>cap</code> to *this.  <br /></td></tr>
<tr class="separator:a94e580adfc3e150a95e29a2399a5ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c1c41bc977804a4bbf23de5af7cac" id="r_a2c4c1c41bc977804a4bbf23de5af7cac"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2c4c1c41bc977804a4bbf23de5af7cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2c4c1c41bc977804a4bbf23de5af7cac">emplace_back</a> (<a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a1fdf8e8c8968ac3345e41b61ca112624">size_type</a> anchor, <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a1fdf8e8c8968ac3345e41b61ca112624">size_type</a> replaced, Args &amp;&amp;... atoms)</td></tr>
<tr class="memdesc:a2c4c1c41bc977804a4bbf23de5af7cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct a cap in place.  <br /></td></tr>
<tr class="separator:a2c4c1c41bc977804a4bbf23de5af7cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5201a51286855c2b3131050845b436" id="r_abb5201a51286855c2b3131050845b436"><td class="memTemplParams" colspan="2">template&lt;typename BeginItr , typename EndItr &gt; </td></tr>
<tr class="memitem:abb5201a51286855c2b3131050845b436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#abb5201a51286855c2b3131050845b436">get_cap_indices</a> (BeginItr &amp;&amp;begin, EndItr &amp;&amp;end) const</td></tr>
<tr class="memdesc:abb5201a51286855c2b3131050845b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the set of caps for a set of indices.  <br /></td></tr>
<tr class="separator:abb5201a51286855c2b3131050845b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b400c4070c10ee636a2b5cc2029ad7" id="r_af7b400c4070c10ee636a2b5cc2029ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#af7b400c4070c10ee636a2b5cc2029ad7">get_cap_indices</a> (const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> &amp;fragment_indices) const</td></tr>
<tr class="memdesc:af7b400c4070c10ee636a2b5cc2029ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the set of cap indices for a set fragment indices.  <br /></td></tr>
<tr class="separator:af7b400c4070c10ee636a2b5cc2029ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4921c7bb2774334331d5d61603e01de1" id="r_a4921c7bb2774334331d5d61603e01de1"><td class="memTemplParams" colspan="2">template&lt;typename BeginItr , typename EndItr &gt; </td></tr>
<tr class="memitem:a4921c7bb2774334331d5d61603e01de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ac9bd0c72619f005c03abb2ca2ca959c1">nuclei_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a4921c7bb2774334331d5d61603e01de1">get_cap_nuclei</a> (BeginItr &amp;&amp;begin, EndItr &amp;&amp;end)</td></tr>
<tr class="memdesc:a4921c7bb2774334331d5d61603e01de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nuclei needed to cap the input fragment.  <br /></td></tr>
<tr class="separator:a4921c7bb2774334331d5d61603e01de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc133fcf8a5534c9829b1e0bd6bb2c48" id="r_afc133fcf8a5534c9829b1e0bd6bb2c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ac9bd0c72619f005c03abb2ca2ca959c1">nuclei_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#afc133fcf8a5534c9829b1e0bd6bb2c48">get_cap_nuclei</a> (const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> &amp;fragment_indices)</td></tr>
<tr class="memdesc:afc133fcf8a5534c9829b1e0bd6bb2c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nuclei needed to cap <code>fragment_indices</code>.  <br /></td></tr>
<tr class="separator:afc133fcf8a5534c9829b1e0bd6bb2c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fffeb6822c3759fc1d23adacf9fa139" id="r_a3fffeb6822c3759fc1d23adacf9fa139"><td class="memTemplParams" colspan="2">template&lt;typename BeginItr , typename EndItr &gt; </td></tr>
<tr class="memitem:a3fffeb6822c3759fc1d23adacf9fa139"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ab055da917e74cd5c23f66d5fcc27bf39">const_nuclei_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3fffeb6822c3759fc1d23adacf9fa139">get_cap_nuclei</a> (BeginItr &amp;&amp;begin, EndItr &amp;&amp;end) const</td></tr>
<tr class="memdesc:a3fffeb6822c3759fc1d23adacf9fa139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nuclei needed to cap the input fragment.  <br /></td></tr>
<tr class="separator:a3fffeb6822c3759fc1d23adacf9fa139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac62956903cbcd49dd60a0ff42ad9bdb" id="r_aac62956903cbcd49dd60a0ff42ad9bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ab055da917e74cd5c23f66d5fcc27bf39">const_nuclei_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#aac62956903cbcd49dd60a0ff42ad9bdb">get_cap_nuclei</a> (const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> &amp;fragment_indices) const</td></tr>
<tr class="memdesc:aac62956903cbcd49dd60a0ff42ad9bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nuclei needed to cap <code>fragment_indices</code>.  <br /></td></tr>
<tr class="separator:aac62956903cbcd49dd60a0ff42ad9bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The set of caps associated with a fragment. </p>
<p>When a fragment of a molecule severs covalent bonds, those bonds must be capped. This class is used to track the caps. For design details see: <a href="https://nwchemex.github.io/Chemist/developer/design/chemistry/caps.html">https://nwchemex.github.io/Chemist/developer/design/chemistry/caps.html</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a14f9f28d03190f645fa5a0475422d1a4" name="a14f9f28d03190f645fa5a0475422d1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f9f28d03190f645fa5a0475422d1a4">&#9670;&#160;</a></span>CapSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chemist::fragmenting::CapSet::CapSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates ane empty <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a>. </p>
<p>The <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a> resulting from the default ctor has no caps in it. Caps can be added by calling either push_back or add_cap.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa222cd7235f4b569e14bf257f7d83e9b" name="aa222cd7235f4b569e14bf257f7d83e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa222cd7235f4b569e14bf257f7d83e9b">&#9670;&#160;</a></span>CapSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chemist::fragmenting::CapSet::CapSet </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3db5aec49302fe3ea084439b36d848d9">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a> initialized to the values in <code>il</code>. </p>
<p>This ctor is intended primarily for unit testing and tutorials as it requires you to initialize *this with a compile-time known number of caps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The caps to initialize *this with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory for the initial state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91e0900400dfd9715e76e76d7e085e4e" name="a91e0900400dfd9715e76e76d7e085e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e0900400dfd9715e76e76d7e085e4e">&#9670;&#160;</a></span>CapSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BeginItr , typename EndItr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">chemist::fragmenting::CapSet::CapSet </td>
          <td>(</td>
          <td class="paramtype">BeginItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a> from a range of <a class="el" href="classchemist_1_1fragmenting_1_1Cap.html" title="Caps a severed bond.">Cap</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BeginItr</td><td>Type of the iterator pointing to the first cap. </td></tr>
    <tr><td class="paramname">EndItr</td><td>Type of the iterator pointing to just past the last cap.</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor is used when the user already has the Caps in a container, or when the caps are being created by a generator object. The resulting <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html" title="The set of caps associated with a fragment.">CapSet</a> object will contain the <a class="el" href="classchemist_1_1fragmenting_1_1Cap.html" title="Caps a severed bond.">Cap</a> objects in the range [begin, end()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">begin</td><td>The iterator pointing to the first cap. After this ctor has run <code>begin</code> will be equal to <code>end</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">end</td><td>The iterator pointing to just past the last cap. This ctor will not modify <code>end</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the internal state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c4c1c41bc977804a4bbf23de5af7cac" name="a2c4c1c41bc977804a4bbf23de5af7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4c1c41bc977804a4bbf23de5af7cac">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chemist::fragmenting::CapSet::emplace_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a1fdf8e8c8968ac3345e41b61ca112624">size_type</a>&#160;</td>
          <td class="paramname"><em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a1fdf8e8c8968ac3345e41b61ca112624">size_type</a>&#160;</td>
          <td class="paramname"><em>replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>atoms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to construct a cap in place. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>The types of the atoms comprising the caps. Must be implicitly convertible to atom_type or to the type of an iterator over atom_type objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">anchor</td><td>The index of atom the cap is attached to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replaced</td><td>The index of the atom the cap is replacing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">atoms</td><td>The atoms comprising the cap or a pair of iterators.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem creating the cap or adding it to *this. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb5201a51286855c2b3131050845b436" name="abb5201a51286855c2b3131050845b436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5201a51286855c2b3131050845b436">&#9670;&#160;</a></span>get_cap_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BeginItr , typename EndItr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> chemist::fragmenting::CapSet::get_cap_indices </td>
          <td>(</td>
          <td class="paramtype">BeginItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the set of caps for a set of indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BeingItr</td><td>The type of the iterator pointing to the first index. </td></tr>
    <tr><td class="paramname">EndItr</td><td>The type of the iterator pointing to just past the last index.</td></tr>
  </table>
  </dd>
</dl>
<p>This method fills in an object of type <code>index_set_type</code> from the provided iterators and then dispatches to get_caps(index_set_type). See the description for get_caps(index_set_type) for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">begin</td><td>An iterator pointing to the first index. After this method is called <code>begin</code> will be equal to <code>end</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">end</td><td>An iterator pointing to just past the last index. This method does not change <code>end</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container with the indices of the caps needed to cap the fragment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Weak throw guarantee because <code>begin</code> will be in a valid, but otherwise undefined state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7b400c4070c10ee636a2b5cc2029ad7" name="af7b400c4070c10ee636a2b5cc2029ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b400c4070c10ee636a2b5cc2029ad7">&#9670;&#160;</a></span>get_cap_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">CapSet::index_set_type</a> chemist::fragmenting::CapSet::get_cap_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> &amp;&#160;</td>
          <td class="paramname"><em>fragment_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the set of cap indices for a set fragment indices. </p>
<p>Typically fragments are specified by stating the indices of the elements which are in the fragment. If any of those indices is an anchor index and the corresponding replaced index is not in the fragment, then a bond has been broken. This method returns the indices of the caps needed for the input fragment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fragment_indices</td><td>Indices for the elements which are in the fragment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container with the indices of the caps needed for the fragment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4921c7bb2774334331d5d61603e01de1" name="a4921c7bb2774334331d5d61603e01de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4921c7bb2774334331d5d61603e01de1">&#9670;&#160;</a></span>get_cap_nuclei() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BeginItr , typename EndItr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ac9bd0c72619f005c03abb2ca2ca959c1">nuclei_reference</a> chemist::fragmenting::CapSet::get_cap_nuclei </td>
          <td>(</td>
          <td class="paramtype">BeginItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nuclei needed to cap the input fragment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BeginItr</td><td>The type of the iterator that points to the index of the first nucleus. </td></tr>
    <tr><td class="paramname">EndItr</td><td>The type of the iterator that points to just past the index of the last nucleus.</td></tr>
  </table>
  </dd>
</dl>
<p>This method uses the provided iterators to initialize a container of type index_set_type. The resulting container is then forwarded to <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#afc133fcf8a5534c9829b1e0bd6bb2c48" title="Returns the nuclei needed to cap fragment_indices.">get_cap_nuclei(const index_set_type&amp;)</a>. See the documentation of <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#afc133fcf8a5534c9829b1e0bd6bb2c48" title="Returns the nuclei needed to cap fragment_indices.">get_cap_nuclei(const index_set_type&amp;)</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">begin</td><td>The iterator which points to the index of the first nucleus in the fragment. After this method is called <code>begin</code> will equal <code>end</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">end</td><td>The iterator which points to just past the index of the last nucleus in the fragment. This method will leave <code>end</code> unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable view of a <a class="el" href="classchemist_1_1Nuclei.html" title="Represents a container of Nucleus objects.">Nuclei</a> object containing the nuclei needed to cap the input fragment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Weak throw guarantee as <code>begin</code> will be in a valid, but otherwise undefined state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fffeb6822c3759fc1d23adacf9fa139" name="a3fffeb6822c3759fc1d23adacf9fa139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fffeb6822c3759fc1d23adacf9fa139">&#9670;&#160;</a></span>get_cap_nuclei() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BeginItr , typename EndItr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ab055da917e74cd5c23f66d5fcc27bf39">const_nuclei_reference</a> chemist::fragmenting::CapSet::get_cap_nuclei </td>
          <td>(</td>
          <td class="paramtype">BeginItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nuclei needed to cap the input fragment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BeginItr</td><td>The type of the iterator that points to the index of the first nucleus. </td></tr>
    <tr><td class="paramname">EndItr</td><td>The type of the iterator that points to just past the index of the last nucleus.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is the same as the non-const version except that the resulting view is read-only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">begin</td><td>The iterator which points to the index of the first nucleus in the fragment. After this method is called <code>begin</code> will equal <code>end</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">end</td><td>The iterator which points to just past the index of the last nucleus in the fragment. This method will leave <code>end</code> unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only view of a <a class="el" href="classchemist_1_1Nuclei.html" title="Represents a container of Nucleus objects.">Nuclei</a> object containing the nuclei needed to cap the input fragment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Weak throw guarantee as <code>begin</code> will be in a valid, but otherwise undefined state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc133fcf8a5534c9829b1e0bd6bb2c48" name="afc133fcf8a5534c9829b1e0bd6bb2c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc133fcf8a5534c9829b1e0bd6bb2c48">&#9670;&#160;</a></span>get_cap_nuclei() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ac9bd0c72619f005c03abb2ca2ca959c1">CapSet::nuclei_reference</a> chemist::fragmenting::CapSet::get_cap_nuclei </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> &amp;&#160;</td>
          <td class="paramname"><em>fragment_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nuclei needed to cap <code>fragment_indices</code>. </p>
<p>Given a set of indices corresponding to the nuclei in the fragment, <code>fragment_indices</code>, this method will find the caps needed for the fragment, combine the nuclei into a <a class="el" href="classchemist_1_1Nuclei.html" title="Represents a container of Nucleus objects.">Nuclei</a> object, and return a view of the <a class="el" href="classchemist_1_1Nuclei.html" title="Represents a container of Nucleus objects.">Nuclei</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fragment_indices</td><td>The indices of the nuclei in the fragment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable view of a <a class="el" href="classchemist_1_1Nuclei.html" title="Represents a container of Nucleus objects.">Nuclei</a> object containing the nuclei needed to cap the input fragment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac62956903cbcd49dd60a0ff42ad9bdb" name="aac62956903cbcd49dd60a0ff42ad9bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac62956903cbcd49dd60a0ff42ad9bdb">&#9670;&#160;</a></span>get_cap_nuclei() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#ab055da917e74cd5c23f66d5fcc27bf39">CapSet::const_nuclei_reference</a> chemist::fragmenting::CapSet::get_cap_nuclei </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a2d658d762436cea8a70e090ed07c2d6e">index_set_type</a> &amp;&#160;</td>
          <td class="paramname"><em>fragment_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nuclei needed to cap <code>fragment_indices</code>. </p>
<p>This method is the same as the non-const version except that the resulting view is read-only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fragment_indices</td><td>The indices of the nuclei in the fragment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only view of a <a class="el" href="classchemist_1_1Nuclei.html" title="Represents a container of Nucleus objects.">Nuclei</a> object containing the nuclei needed to cap the input fragment.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94e580adfc3e150a95e29a2399a5ae0e" name="a94e580adfc3e150a95e29a2399a5ae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e580adfc3e150a95e29a2399a5ae0e">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void chemist::fragmenting::CapSet::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classchemist_1_1fragmenting_1_1CapSet.html#a3db5aec49302fe3ea084439b36d848d9">value_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>cap</code> to *this. </p>
<p>This method can be used to add an already created <a class="el" href="classchemist_1_1fragmenting_1_1Cap.html" title="Caps a severed bond.">Cap</a> instance to *this. The cap is appended on to the end of *this. If prior to calling this method *this has <picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$n$" src="form_27.png"/></picture> caps. After a successful invocation of this method, *this will have <picture><source srcset="form_28_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$n + 1$" src="form_28.png"/></picture> caps and <picture><source srcset="form_29_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$(*this)[n]$" src="form_29.png"/></picture> will be <code>cap</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cap</td><td>The value being added to *this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a problem allocating memory for storing <code>cap</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/chemist/fragmenting/capping/<a class="el" href="cap__set_8hpp_source.html">cap_set.hpp</a></li>
<li>src/chemist/fragmenting/capping/<b>cap_set.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
